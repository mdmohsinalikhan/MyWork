Name: Md. Mohsin Ali Khan
Student No: 336790


1. Debuggers, Windows, emulation (3 points)
-------------------------------------------

Are the following claims true or false? Justify your answers.

1.1. A process can have only one debugger attached to it at a time. (0.5 points)
Answer: True. If two debugger is attached  then one of them can receive the notification but the other cant.

1.2. The structured exception handlers (SEH) are stored in a linked list in the Process Environment Block (PEB) of a process. (0.5 points)
Answer: False. The pointer to SEH is mentioned at offset 0x00 of TEB

1.3. On Windows, the debugger receives a first-chance notification of an exception even before the application has a chance to handle it. (0.5 points)
Answer: True. Because that is how it is designed

1.4. Since hardware breakpoints on x86 are implemented using special debug registers, the target process (debuggee) can easily remove or modify them by using the MOV instruction to change the contents of DR0-DR7 registers. (0.5 points)
Answer: True. Because during exception handling the move command can clean the DR registers.

1.5. Fetch-decode-execute interpreter emulates instructions one basic block at a time. (0.5 points)
False. It executes one quad at a time. where as basic block is a sequence of instructions without any jump

1.6. Emulation with code translation is slower than the traditional fetch-decode-execute approach if the emulated code itself contains long loops. (0.5 points)
Answer: False. Emulation with code translation is faster than the traditional fetch-decode-execute approach. Because in the traditional approach for each iteration of the loop all the instructions are fetched-decoded-executed. But in case of code translation a single basic block is translated and chached.


2. Windows Internals (2 points)
-------------------------------

Answer the following questions:

2.1. What role do the registers eax and edx play in the modern Windows system call interface? (0.5 points)
Answer: eax contains the system call number/ordinal and edx contains address of the first argument


2.2. What component in Windows user mode implements the system call interface? (0.5 points)
Answer: ntdll.dll . This how it is designed.


2.3. What parts are protected with the Kernel Patch Protection feature of Windows? (0.5 points)
Answer:  Modifying system service tables
             Modifying the interrupt descriptor table
             Modifying the global descriptor table
             Using kernel stacks not allocated by the kernel



2.4. Why is Kernel Patch Protection disabled when kernel mode debugging is enabled? (hint: we are looking for two possible reasons) (0.5 points)
Anwer: To enable setting breakpoints during the development, test, and diagnostic phase of kernel software development.
           To prevent the debugging of KPP


3. Debugging I (6 points)
-------------------------

Analyze sample hw2ex3.bin using a debugger. The sample is not malicious. Use a 32-bit Windows for analysis. The main function starts at 0x401080. Debugging has been tested with OllyDbg 1.10 (http://www.ollydbg.de/odbg110.zip). The sample requires msvcr100.dll from Microsoft Visual C++ 2010 Redistributable Package (the DLL is included in the ZIP). Answer the following questions:

3.1. What is the right password? Explain the logic that is used to generate the password. (4 points)
Answer: right password is darthvader.

The code calls a function using its address. Like following:call [ebp+var4]
That means it is calling the codes mentioned at the address in ebp-4 memory location in the stack. By using ollydbg it has been found that the called code is actually initializing a memory location with the follwoing values in hex: 41 6E 74 69 76 69 72 75 73 20. Then all these bytes are transferred to some register using movsx (sign extended mov command) and for each byte they are x-or'ed with some hard coded value in the code. Then that converted byte is send back to the memory location again. which results into the following value in hex: 31 34 27 21 3D 23 34 31 30 27

That means the code generates a password and saves it in a memory location. The given password from the command line is first converted from unicode to ascii and then saved in another memory location. It does xor all the ascii characters of the user given password with 0x55. The code generated password is following in hex: 31 34 27 21 3D 23 34 31 30 27 . Now if we xor all these bytes with 0x55 then we get following(in hex):
64 61 72 74 68 76 61 64 65 72 which is actually equivalent to the ascii string: darthvader

3.2. The sample does not use load-time dynamic linking (http://msdn.microsoft.com/en-us/library/ms681914%28v=vs.85%29.aspx) with system libraries. The most interesting functions it calls are missing from the import table. How does it call those functions? (2 points)
Answer: It uses static linking. The linker copies a library function's code into each module that calls it. For example in the image at address 4010F4 there is a function call like following:
call [ebp+var_4]
now [ebp+var_4] is 4012a7. That means it is calling the code mentioned at this address.

3.3. The sample tries to make sure that none of the important strings are easy to spot at first sight. How does the sample protect/hide its strings? (2 points)
Answer: 
String literal. What ever it want to print is written in a memory location, then it calls the wprintf/printf function with the format argument only with %s as the first argument and an address to a string (which it wants to be printed) as the second argument. So to know what the string is, one has to check the address to the string in correspondece with the %s in the format argument. Bottom line is, it sends the format argument of printf/wprintf function only with %s and every thing is mentioned in the memory address which is sent as the second argument.

Most imporantly, it tries to hide its string by doing xor each character with a constant value. In the code whenever it tries to use the hidden string it calls the function sub_401000. It sends two argument to it. The first one is the string which needs to be processed before printing and the second argument is a constant value of 1 byte. For example when it calls the function sub_401000 at the address 401232, it passes the constant value 0x55h. This constant value is xor'ed with each character in the string. Thus it tries to hied it strings.


4. Debugging II (8 points)
-----------------------

Analyze sample hw2ex4.bin using a debugger. The sample is not malicious. Use a 32-bit Windows for analysis. The main function starts at 0x401000. Debugging has been tested with OllyDbg 1.10.

4.1. The sample uses three anti-debugging tricks. What are those? How did you pass the anti-debugging tricks? (3 points)
Answer:
 i) It generates exception by causing divide by zero
        Passing the anti-debugging trick: I have changed the debugging option of ollydbg. Setting the option of Ignoring the division by zero(pass to debugged program) exception.
 ii) It detects the presence of a debugger and exit
        Passing the anti-debugging trick: I have edited the value of the memory location 407D48 greater or equal to 3 and it do not abort anymore


4.2. Sample protects the most important logic from static analysis. How? (1 point)
        Answer: The password is gnerated with the help of srand and rand function. The srand function requires seed value. The part of the code which generates the seed is being modified on runtime by doing xor in between every byte of the code of that portion with 0xBEh. And the generated code is not visible in standard assembly code format.

4.3. For the protection routine mentioned in 4.2. to work, the PE header had to be modified. What has been modified? Hint: you can compare the values to a normal PE file, e.g. Notepad. (1 point)
        Answer: 

4.4. What is the password? Explain the logic that is used to generate the password. (4 points)
     Answer: The right password is s2r45
             The password is generated by the calling of sprintf function with the format s%dr%d where the first %d is the seed used to generated a random number. In this case it is 2 and the second %d is the random number generated using seed value 2, which is 45. Altogether it makes the password: s2r45


5. Effort (1 point)
-------------------

How many hours did you spend answering these questions? Do you think some questions were too easy or too difficult?
Answer: I have spent around 20 Hours. I dont think they are too difficult or too easy.

Regards
Mohsin
